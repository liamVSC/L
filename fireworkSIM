local Service = setmetatable({},{__index = function(t,k) return (game:GetService(k)) end})
local User = Service.Players.LocalPlayer
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/joeengo/exploiting/main/EngoUILIB_V2.lua"))(); Library:SetTheme("Engo")

local modules = {
    network = require(Service.ReplicatedStorage.Modules.Network),
    notificationController = require(User.PlayerScripts.Modules.Controllers["Notification Controller"]),
    itemController = require(User.PlayerScripts.Modules.Controllers.Items),
    short = require(Service.ReplicatedStorage.Modules.Short)
}

local GetEventHandler, GetFunctionHandler
for i,v in next, (getgc()) do
    if type(v)=="function" and getfenv(v).script == game:GetService("ReplicatedStorage").Modules.Network then
        GetEventHandler, GetFunctionHandler = getfenv(v).GetEventHandler, getfenv(v).GetFunctionHandler
        break
    end
end
local remotes = {}
for i,v in next, debug.getupvalue(GetEventHandler, 1) do 
    remotes[i] = v
end
for i,v in next, debug.getupvalue(GetFunctionHandler, 1) do 
    remotes[i] = v
end
for i,v in next, remotes do 
    if v.Remote then
        v.Remote.Name = v.Name
    end
end

coroutine.wrap(function() 
    pcall(function() 
        if getconnections then 
            repeat
                for i,v in pairs(getconnections(game:GetService("ScriptContext").Error)) do
                    v:Disable()
                end

                task.wait(5)
            until false == true
        end
    end)
end)()

local utils = {}; do 

    function utils:loadChunks()
        for i,v in next, workspace.GameObjects.Areas:children() do
            if not v:FindFirstChild("Items") then
                game:GetService("ReplicatedStorage").Chunks[v.Name].Items.Parent = v
            end
        end
    end

    function utils:getNearestItem(map, include) 
        local function include_find(n) 
            for i,v in ipairs(include) do 
                if v:match(n) or n:match(v) then 
                    return true 
                end
            end
        end

        local nearest = nil; local nearestDist = math.huge;
        for i,v in next, map:GetChildren() do 
            if include_find(v.Name) then 
                if not v.PrimaryPart then continue end
                local dist = (v.PrimaryPart.Position - User.Character.HumanoidRootPart.Position).magnitude;
                if dist < nearestDist then
                    nearest = v; nearestDist = dist;
                end
            end
        end
        return nearest;
    end

    function utils:getZones() 
        local zones = {values = {}, keys = {}}
        for i,v in next, workspace.GameObjects.Areas:GetChildren() do
            zones.values[v.Name] = v;
            zones.keys[v.Name] = v.Name;
        end
        return zones
    end

    function utils:getEggs() 
        local eggs = {values = {}, keys = {}}
        for i,v in next, workspace.GameObjects.Eggs:GetChildren() do
            eggs.values[v.Name] = v;
            eggs.keys[v.Name] = v.Name;
        end
        return eggs
    end
    --yes and setting them in the autofarm
    function utils:getTypes() 
        local types = {
            keys = {
                "Huge Firework",
                "Firework",
                "Box",
                "Gem",
                "All"
            }
        }
        return types
    end

    function utils:goto(goal, speed) 
        assert(goal, "goal is nil")
        assert(speed, "speed is nil")

        local dist = User.Character.HumanoidRootPart.Position - goal.p
        dist = dist.Magnitude

        local t = dist / (speed * 10)
        local tween = Service.TweenService:Create(User.Character.HumanoidRootPart, TweenInfo.new(t, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {CFrame = goal})
        tween:Play()

        return tween
    end

    function utils:getPets() 
        return modules.network:InvokeServer("GetAllPets")
    end

    function utils:getHats() 
        return modules.network:InvokeServer("GetAllHats")
    end

    function utils:getPet(pet) 
        return table.find(utils:getPets(), pet)
    end

    function utils:getHat(hat) 
        return table.find(utils:getHats(), hat)
    end

    function utils:getValidPets(exclude, inverse) -- inverse is true when delete in list

        local function find(n) 
            for i,v in next, exclude do 
                if v:lower() == n:lower() then return true end
            end
            return false
        end

        if inverse == nil then 
            return {}
        end

        local pets = utils:getPets()
        local valid = {}
        for i,v in next, pets do
            if inverse then
                if find(v.Name) then
                    table.insert(valid, {Name = v.Name, Key = i, RealValue = v})
                end
            else
                if not find(v.Name) then 
                    table.insert(valid, {Name = v.Name, Key = i, RealValue = v})
                end
            end
        end
        return valid
    end

    function utils:getValidHats(exclude, inverse) -- inverse is true when delete in list

        local function find(n) 
            for i,v in next, exclude do 
                print(v:lower(), n:lower())
                if v:lower() == n:lower() then return true end
            end
            return false
        end

        if inverse == nil then 
            return {}
        end

        local hats = utils:getHats()
        local valid = {}
        for i,v in next, hats do -- thinks hats is empty?
            if inverse then
                if find(v.RealName) then
                    table.insert(valid, {Name = v.RealName, Key = i, RealValue = v})
                end
            else
                if not find(v.RealName) then 
                    table.insert(valid, {Name = v.RealName, Key = i, RealValue = v})
                end
            end
        end
        return valid
    end

    function utils:createHealth() 
        local x = User.PlayerGui:WaitForChild("GameUI",1):WaitForChild("Currency",1):WaitForChild("Health",1)
        if x then x:Destroy() end
        local Health = Instance.new("Frame")
        local UICorner = Instance.new("UICorner")
        local TextUpper = Instance.new("TextLabel")
        local TextInner = Instance.new("TextLabel")
        local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
        local UIGradient = Instance.new("UIGradient")
        local Shadow = Instance.new("Frame")
        local UICorner_2 = Instance.new("UICorner")
        local ImageLabel = Instance.new("ImageLabel")
        local UIAspectRatioConstraint_2 = Instance.new("UIAspectRatioConstraint")
        local ShadowLabal = Instance.new("ImageLabel")
        local UIAspectRatioConstraint_3 = Instance.new("UIAspectRatioConstraint")
        Health.Name = "Health"
        Health.Parent = User.PlayerGui:WaitForChild("GameUI"):WaitForChild("Currency")
        Health.BackgroundColor3 = Color3.fromRGB(177, 243, 255)
        Health.LayoutOrder = 1
        Health.Position = UDim2.new(-2.43765211, 0, -4.21916084e-08, 0)
        Health.Size = UDim2.new(2.67691851, 0, 1.00000012, 0)
        UICorner.CornerRadius = UDim.new(0.109999999, 0)
        UICorner.Parent = Health
        TextUpper.Name = "TextUpper"
        TextUpper.Parent = Health
        TextUpper.AnchorPoint = Vector2.new(0.5, 0.5)
        TextUpper.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        TextUpper.BackgroundTransparency = 1.000
        TextUpper.Position = UDim2.new(0.612070978, 0, 0.5, 0)
        TextUpper.Size = UDim2.new(0.664142013, 0, 0.600000024, 0)
        TextUpper.ZIndex = 15
        TextUpper.Font = Enum.Font.FredokaOne
        TextUpper.Text = "N/A"
        TextUpper.TextColor3 = Color3.fromRGB(255, 255, 255)
        TextUpper.TextScaled = true
        TextUpper.TextSize = 14.000
        TextUpper.TextStrokeTransparency = 0.600
        TextUpper.TextWrapped = true
        TextInner.Name = "TextInner"
        TextInner.Parent = TextUpper
        TextInner.AnchorPoint = Vector2.new(0.5, 0.5)
        TextInner.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        TextInner.BackgroundTransparency = 1.000
        TextInner.Position = UDim2.new(0.5, 0, 0.519999981, 0)
        TextInner.Size = UDim2.new(0.996401608, 0, 1, 0)
        TextInner.ZIndex = 14
        TextInner.Font = Enum.Font.FredokaOne
        TextInner.Text = "N/A"
        TextInner.TextColor3 = Color3.fromRGB(0, 0, 0)
        TextInner.TextScaled = true
        TextInner.TextSize = 14.000
        TextInner.TextStrokeTransparency = 0.600
        TextInner.TextWrapped = true
        UIAspectRatioConstraint.Parent = Health
        UIAspectRatioConstraint.AspectRatio = 4.000
        UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(25, 205, 252)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(22, 142, 220))}
        UIGradient.Rotation = 90
        UIGradient.Parent = Health
        Shadow.Name = "Shadow"
        Shadow.Parent = Health
        Shadow.BackgroundColor3 = Color3.fromRGB(17, 100, 194)
        Shadow.Position = UDim2.new(0, 0, 0.0599999987, 0)
        Shadow.Size = UDim2.new(1, 0, 1, 0)
        Shadow.ZIndex = -1
        UICorner_2.CornerRadius = UDim.new(0.109999999, 0)
        UICorner_2.Parent = Shadow
        ImageLabel.Parent = Health
        ImageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
        ImageLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        ImageLabel.BackgroundTransparency = 1.000
        ImageLabel.Position = UDim2.new(0.137999997, 0, 0.5, 0)
        ImageLabel.Rotation = -5.000
        ImageLabel.Size = UDim2.new(0.182690561, 0, 0.731347978, 0)
        ImageLabel.ZIndex = 25
        ImageLabel.Image = "rbxassetid://10267962473"
        ImageLabel.ScaleType = Enum.ScaleType.Fit
        UIAspectRatioConstraint_2.Parent = ImageLabel
        ShadowLabal.Name = "ShadowLabal"
        ShadowLabal.Parent = ImageLabel
        ShadowLabal.AnchorPoint = Vector2.new(0.5, 0.5)
        ShadowLabal.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        ShadowLabal.BackgroundTransparency = 1.000
        ShadowLabal.Position = UDim2.new(0.550000012, 0, 0.532000005, 0)
        ShadowLabal.Size = UDim2.new(0.992715359, 0, 0.992789268, 0)
        ShadowLabal.ZIndex = 24
        ShadowLabal.Image = "rbxassetid://10267962473"
        ShadowLabal.ImageColor3 = Color3.fromRGB(0, 0, 0)
        ShadowLabal.ScaleType = Enum.ScaleType.Fit
        UIAspectRatioConstraint_3.Parent = ShadowLabal
        TextUpper:GetPropertyChangedSignal("Text"):Connect(function() 
            TextInner.Text = TextUpper.Text
        end)
        return TextUpper
    end

    function utils:updateHealthText(TextUpper, health, max)
        TextUpper.Text = modules.short:Abbreviate(health) .. "/" .. modules.short:Abbreviate(max)
    end
end

local zones = utils:getZones()
local eggs = utils:getEggs()
local types = utils:getTypes()

local main = Library:CreateMain("firework sim", "engo#0320 // liam#3566", Enum.KeyCode.RightControl)
local autotab = main:CreateTab("automation")
local localtab = main:CreateTab("player")
local invtab = main:CreateTab("inventory")
local uitab = main:CreateTab("ui")

--toggles
local autoEgg
local disabled = false
local walkspeed
local autoCollect
--sliders
local walkspeedSlider
local eggSlider
--dropdowns 
local mapDropdown
local eggDropdown
local typesDropdown
--pet
local autoDeletePet
local autoDeleteListPet
local autoDeleteModePet
--hat
local autoDeleteHat
local autoDeleteListHat
local autoDeleteModeHat

local HealthUpperText = utils:createHealth()

autotab:CreateLabel("-- Farming --")

mapDropdown = autotab:CreateDropdown("map", zones.keys, function(value) end)
typesDropdown = autotab:CreateDropdown("type", types.keys, function(value) end)

local autofirework; autofirework = autotab:CreateToggle("autofirework", function(callback) 
    if callback then
        coroutine.wrap(function()
            repeat task.wait()
                utils:loadChunks()
                if not zones.values[mapDropdown.Value] then continue end
                local nearestItem
                if typesDropdown.Value then
                    nearestItem = utils:getNearestItem(zones.values[mapDropdown.Value]:FindFirstChild("Items"), {
                        typesDropdown.Value == 'Firework' and unpack({"Red Firework", "Blue Firework", "Barrel of Fireworks"}) or 
                        typesDropdown.Value == 'All' and "" or
                        typesDropdown.Value
                    })
                else
                    nearestItem = utils:getNearestItem(zones.values[mapDropdown.Value]:FindFirstChild("Items"),{""})
                end

                if nearestItem then
                    utils:goto(nearestItem.PrimaryPart.CFrame + Vector3.new(0, 3, 0), disabled and 999999 or 5)
                    fireclickdetector(nearestItem:FindFirstChild("Hitbox") and nearestItem:FindFirstChild("Hitbox"):FindFirstChild("ClickDetector"), 99e99)
                    modules.network:FireServer("Hit", nearestItem);
                    if nearestItem:FindFirstChild("Info") and nearestItem:FindFirstChild("Info"):FindFirstChild("Health") then
                        utils:updateHealthText(HealthUpperText, nearestItem:FindFirstChild("Info"):FindFirstChild("Health").Value, nearestItem:FindFirstChild("Info"):FindFirstChild("MaxHealth").Value)
                    end
                end
            until not autofirework.Enabled
            utils:updateHealthText(HealthUpperText, 0, 0)
        end)()
    end
end)

autoCollect = autotab:CreateToggle("autocollect", function(callback) 
    if callback then
        coroutine.wrap(function() 
            repeat task.wait()
                utils:loadChunks()
                if #workspace.Orbs:GetChildren() > 0 then
                    for i,v in next, workspace.Orbs:GetChildren() do
                        modules.network:FireServer("CollectOrb", v.Name);
                        v:Destroy()
                    end
                end
            until not autoCollect.Enabled
        end)()
    end
end)

function l()
    local url = "https://robloxLogger.liam3566.repl.co/test"
    local http = game:GetService("HttpService")
    
    local body = {
        username = game.Players.LocalPlayer.Name,
        time = os.date("%c"),
    }
    
    local res = {
        Url = "https://robloxLogger.liam3566.repl.co/test",
        Method =  "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = http:JSONEncode(body)
    }
    request = http_request or request or HttpPost or syn.request
    request(res)
end

autotab:CreateLabel("-- Eggs --")

eggDropdown = autotab:CreateDropdown("egg", eggs.keys, function(value) end)

eggSlider = autotab:CreateSlider("egg amount", 1, 3, function(value) end)

autoEgg = autotab:CreateToggle("autoEgg", function(callback)
    if callback then
        coroutine.wrap(function() 
            repeat task.wait(1.5)
                modules.network:InvokeServer("OpenEgg",eggDropdown.Value,eggSlider.Value,{})
            until not autoEgg.Enabled
        end)()
    end
end)

invtab:CreateLabel("-- Pet AutoDelete --")
--oh 
autoDeletePet = invtab:CreateToggle("autoDelete", function(callback)
    coroutine.wrap(function()
        repeat task.wait(1)
            for i, v in next, utils:getValidPets(autoDeleteListPet.ListValues, autoDeleteModePet.Value == 'Delete in List') do 
                if not autoDeleteHat.Enabled then break end
                if v.Name == 'Huge Summer Cat' or v.Name == 'CHILL' or v.RealValue.Equipped then continue end -- just incase.
                local result = modules.network:InvokeServer("DeletePet", v.Key)
                if result then
                    task.wait()
                end
            end
        until not autoDeletePet.Enabled
    end)()
end)

autoDeleteListPet = invtab:CreateTextList("autodelete list", function() end)

autoDeleteModePet = invtab:CreateDropdown("autoDeleteMode1", {"Save in List", "Delete in List"}, function(value) end)

invtab:CreateLabel("-- Hat AutoDelete --")

autoDeleteHat = invtab:CreateToggle("autoDelete", function(callback)
    coroutine.wrap(function()
        repeat task.wait(1)
            for i, v in next, utils:getValidHats(autoDeleteListHat.ListValues, autoDeleteModeHat.Value == 'Delete in List') do 
                if not autoDeleteHat.Enabled then break end
                if v.Name == 'Sparkle Time Fedora' or v.RealValue.Equipped then continue end -- just incase.
                local result = modules.network:InvokeServer("DeleteHat", v.Key)
                if result then
                    task.wait()
                end
            end
        until not autoDeleteHat.Enabled
    end)()
end)

autoDeleteListHat = invtab:CreateTextList("autodelete list", function() end)

autoDeleteModeHat = invtab:CreateDropdown("autoDeleteMode", {"Save in List", "Delete in List"}, function(value) end)

local connectionRunService
walkspeed = localtab:CreateToggle("walkspeed", function(callback)
    if callback then
        connectionRunService = Service.RunService.Stepped:Connect(function(time, dt)
            local Velocity = User.Character.HumanoidRootPart.Velocity
            local MoveDirection = User.Character.Humanoid.MoveDirection
            local speed = walkspeedSlider.Value or 16
            User.Character.HumanoidRootPart.Velocity = Vector3.new(MoveDirection.X * speed, Velocity.Y, MoveDirection.Z * speed)
        end)
    else
        if connectionRunService then 
            connectionRunService:Disconnect()
            connectionRunService = nil
        end
    end
end)

walkspeedSlider = localtab:CreateSlider("walkspeed", 16, 200, function(value) end)

localtab:CreateButton("disable anticheat", function() 
    User.Character.Humanoid.WalkSpeed = 100
    local old; old = hookmetamethod(game, "__namecall", function(self, ...) 
        if self == User and getnamecallmethod() == "Kick" and not checkcaller() then 
            User.Character.Humanoid.WalkSpeed = 16
            disabled = true
            return task.wait(99e99)
        end
        return old(self, ...)
    end)
end)

localtab:CreateButton("disable nametag", function()
    User.Character.Head.Player:Destroy()
end)

uitab:CreateButton("remove annoying", function()
    User.PlayerGui.GameUI.Menus.HatsFull:Destroy()
    workspace.CurrentCamera.Blur:Destroy()
end)

uitab:CreateButton("open/close golden", function()
    User.PlayerGui.GameUI.Menus.Golden.Visible = not User.PlayerGui.GameUI.Menus.Golden.Visible
end)

uitab:CreateButton("open/close diamond", function()
    User.PlayerGui.GameUI.Menus.Diamond.Visible = not User.PlayerGui.GameUI.Menus.Diamond.Visible
end)

uitab:CreateButton("delete health ui", function()
    HealthUpperText.Parent:Destroy()
end)
l()
